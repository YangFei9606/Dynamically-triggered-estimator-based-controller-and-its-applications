% The initial position of the rover [1;-1.1;pi/4]
% A video is also provided for you to see the initial position
%% Step 0.1: Basic settings
clear;
clc;
step_size = 8;                        % Control step size in milliseconds
num_agent = 1;                          % Number of agents
dimension = 3;                          % Dimension of system states
% Radius of the rover
rover_R = [0.13,0.13,0.13];   
% Radius of the wheels
wheel_R = [0.05,0.05,0.05];        
% Motor max speed (step/s)
motor_max_speed = [3000,3000,3000];     
% motor step size (switch)
step_size_motor = [1/4,1/4,1/4];
% gearbox amplifier constant
gear_constant = [5.18,5.18,5.18];       
% Saturation limitation in m/s
satu_limit = 0.2 * ones(size(motor_max_speed));

% TCP IP address for each rover
% rover_ip = ['172.20.10.11';'172.20.10.12';'172.20.10.13'];
rover_ip = ['129.127.29.11';'129.127.29.22';'129.127.29.33'];

%% Step 0.2: Set up opti-track
opti = opti_class;
opti.opti_set_up();

%% Step 0.3: Set up the role of PC (one agent only)
pc = pc_class;
rov = struct();
rov.tcp_port = [];
rov.x_i = [0;0;0];
rov.x_di = [0;0;0];
rov.v_di = [0;0;0];
rov.delta_xi = [0;0;0];
rov.serial_num = 0;
rov.x_hat_i = [0;0;0];
rov.w_hat_i = [0;0;0];
rov.u_hat_i = [0;0;0];
rov.x_tilde_i = [0;0;0]; 
rov.beta_sat = [0.1;0.1;0.1];
rov.beta_con = 2;
rov.beta_est = 2;
rov.g_i = zeros(3,3);
rov.u_i = [0;0;0];
rov.E_x = [0;0;0];
rov.trigger_bound = [0;0;0];
rov.x_i_trigger = [0;0;0];    % Triggered measurement

%% Step 1: Wireless communication construction

for i = 1 : num_agent
    % UDP communication
    pc.udp_communication(rover_ip(i,:), step_size);
    pause(1);
    % TCP communication
    r = rover_class;
    r.open_port();
    rov.tcp_port = r.tcp_port;
    r.askID();
    rov.serial_num = r.id;
    % Wait for a period of time
    pause(2);
end

fprintf("Communication construction is completed.\n");

%% Step 2: Real-time networked control
%% Step 2.1: Some basic initialisation
pause(3);
stop_time = 60;     % Task time (second)

% Step 2.2: Data matrix initialisation
% Matrix initialisation
time_matrix = zeros(stop_time/step_size*1000+1,1);

% Agent position read from Opti-track
agent_pos = zeros(stop_time/step_size*1000+1, num_agent * dimension);
agent_pos_trigger = zeros(stop_time/step_size*1000+1, num_agent * dimension);
current_agent_pos = zeros(num_agent * dimension, 1);      % Column vector
current_agent_pos_trigger = zeros(num_agent * dimension, 1); 

% Reference generated by the PC
pos_ref = zeros(stop_time/step_size*1000+1, num_agent * dimension);
vel_ref = zeros(stop_time/step_size*1000+1, num_agent * dimension);
current_pos_ref = zeros(num_agent * dimension, 1);      % Column vector
current_vel_ref = zeros(num_agent * dimension, 1);      % Column vector

% Position tracking error calculated by the PC
delta_x = zeros(stop_time/step_size*1000+1, num_agent * dimension);
delta_x_trigger = zeros(stop_time/step_size*1000+1, num_agent * dimension);
current_delta_x = zeros(num_agent * dimension, 1);      % Column vector
current_delta_x_trigger = zeros(num_agent * dimension, 1);      % Column vector

% Observer states
w_hat = zeros(stop_time/step_size*1000+1, num_agent * dimension);
x_hat = zeros(stop_time/step_size*1000+1, num_agent * dimension);
u_hat = zeros(stop_time/step_size*1000+1, num_agent * dimension);

% Observer errors
x_tilde = zeros(stop_time/step_size*1000+1, num_agent * dimension);
x_tilde_trigger = zeros(stop_time/step_size*1000+1, num_agent * dimension);
current_x_tilde = zeros(num_agent * dimension, 1); 
current_x_tilde_trigger = zeros(num_agent * dimension, 1); 

% Auxiliary variable
beta_sat = zeros(stop_time/step_size*1000+1, num_agent * dimension);
beta_sat(1, 0 * dimension + 1 : 1 * dimension) = rov.beta_sat';

% Control input calculated by the PC (only for networked control structure)
agent_control = zeros(stop_time/step_size*1000+1, num_agent * dimension);
motor_speed = zeros(stop_time/step_size*1000+1, num_agent * dimension);
current_agent_control = zeros(num_agent * dimension, 1);      % Column vector
current_motor_speed = zeros(num_agent * dimension, 1);      % Column vector

% Event-trigger items
E_norm = zeros(stop_time/step_size*1000+1, 1);
beta_con = zeros(stop_time/step_size*1000+1, 1);
beta_est = zeros(stop_time/step_size*1000+1, 1);
beta_con(1) = rov.beta_con;
beta_est(1) = rov.beta_est;
trigger_bound = zeros(stop_time/step_size*1000+1, 3);
trigger_flag = zeros(stop_time/step_size*1000+1, num_agent);
event_num = 0;

% Record the calculation time
agent_sta_time = zeros(stop_time/step_size*1000+1, num_agent);
agent_end_time = zeros(stop_time/step_size*1000+1, num_agent);

% Event-trigger parameters
eta_1 = [21,21,3];
k_1 = [3,3,1];
xi_2 = 0.5;
rho_2 = 0.08;
gamma_2 = 0.6;
alpha_2 = 1;

% Controller
k_2 = [3,3,1.5];
k_3 = [8,8,2];
rho_3 = 0.08;
xi_3 = 0.5;
gamma_3 = 0.6;
alpha_3 = 1;
rho_4 = 0.08;
L_1 = 1.74;
L_2 = 1.42;

% Record the initial time
timer = clock;
ini_time = (timer(4) * 3600 + timer(5) * 60 + timer(6)) * 1000;

% Now we entre the big loop
int_num = 0;           % The number of control iteration
rov.beta_sat = [0.1;0.1;0.1];
rov.beta_con = 2;
rov.beta_est = 2;
% Step 2.3: Begin the big real-time control loop
while 1
    
    % Step 2.3.1: Record the current time
    timer = clock;
    cur_time = (timer(4) * 3600 + timer(5) * 60 + timer(6)) * 1000;
    now_time = cur_time - ini_time;  % Unit: ms
    
    % Step 2.3.2: If the time is triggered
    if now_time >= step_size * int_num
        time_matrix(int_num + 1) = now_time/1000;
        % Step 2.3.2.1: Reference generation and position reading
        for i = 1 : num_agent
            % Record start time
            timer = clock;
            start_time = (timer(4) * 3600 + timer(5) * 60 + timer(6)) * 1000 - ini_time;
            
            % Generate reference
            [rov.x_di, rov.v_di] = pc.reference_generator(now_time/1000, i);
            
            % Read current position from opti-track
            rov.x_i = opti.opti_get_pos(i);
            % Initialise
            if int_num == 0
                rov.x_hat_i = rov.x_i;
                rov.x_i_trigger = rov.x_hat_i;
                current_agent_pos_trigger = rov.x_i_trigger;
                trigger_flag(1) = 1;
                E_x_norm = 0;
                event_num = event_num + 1;
                rov.delta_xi = rov.x_i - rov.x_di;
                rov.x_tilde_i = [0;0;0];
                rov.E_x = [0;0;0];
                K_3 = diag(eta_1) * diag(k_1) - 2 * eye(3);
                F_2 = (L_1 * norm(diag(eta_1) * rov.u_i)^2 * E_x_norm^2/4 + norm(diag(eta_1)* diag(k_1) * rov.E_x)^2/4 + norm(diag(eta_1) * rov.E_x)^2) - rho_2 * rov.x_tilde_i' * K_3 * rov.x_tilde_i;
                F_3 = (L_2 * norm(rov.v_di - rov.w_hat_i - diag(k_3) * rov.beta_sat)^2 * E_x_norm^2 + norm(diag(k_2) * rov.E_x)^2) - rho_3 * rov.delta_xi' * diag(k_2) * rov.delta_xi;
                F_4 = max(k_2) * L_2 * E_x_norm * norm(rov.delta_xi)^2 - rho_4 * (1 - rho_3) * norm(diag(k_2) * rov.delta_xi.^2);

                rov.trigger_bound = [F_2 - gamma_2 * rov.beta_est; F_3 - gamma_3 * rov.beta_con; F_4];
                
                rov.beta_est = rov.beta_est + step_size/1000 * (- alpha_2 * rov.beta_est - F_2 + xi_2);
                rov.beta_con = rov.beta_con + step_size/1000 * (- alpha_3 * rov.beta_con - F_3 + xi_3);
            end
            rov.delta_xi = rov.x_i - rov.x_di;
            rov.x_tilde_i = rov.x_hat_i - rov.x_i;
            rov.E_x = rov.x_i - rov.x_i_trigger;
            
            % Temporary storage
            current_pos_ref((i-1) * dimension + 1 : i * dimension) = rov.x_di;
            current_vel_ref((i-1) * dimension + 1 : i * dimension) = rov.v_di;
            current_agent_pos((i-1) * dimension + 1 : i * dimension) = rov.x_i;
            current_delta_x((i-1) * dimension + 1 : i * dimension) = rov.delta_xi;
            current_x_tilde((i-1) * dimension + 1 : i * dimension) = rov.x_tilde_i;
            
            if int_num > 0 % We do nothing for t_0

                % Event-trigger mechanism
                E_x_norm = norm(rov.E_x);
                K_3 = diag(eta_1) * diag(k_1) - 2 * eye(3);
                F_2 = (L_1 * norm(diag(eta_1) * rov.u_i)^2 * E_x_norm^2/4 + norm(diag(eta_1)* diag(k_1) * rov.E_x)^2/4 + norm(diag(eta_1) * rov.E_x)^2) - rho_2 * rov.x_tilde_i' * K_3 * rov.x_tilde_i;
                F_3 = (L_2 * norm(rov.v_di - rov.w_hat_i - diag(k_3) * rov.beta_sat)^2 * E_x_norm^2 + norm(diag(k_2) * rov.E_x)^2) - rho_3 * rov.delta_xi' * diag(k_2) * rov.delta_xi;
                F_4 = max(k_2) * L_2 * E_x_norm * norm(rov.delta_xi)^2 - rho_4 * (1 - rho_3) * norm(diag(k_2) * rov.delta_xi.^2);

                rov.trigger_bound = [F_2 - gamma_2 * rov.beta_est; F_3 - gamma_3 * rov.beta_con; F_4];

                if max(rov.trigger_bound) > 0
                    trigger_flag(int_num+1) = 1;
                    rov.x_i_trigger = rov.x_i;
                    E_x_norm = 0;
                    event_num = event_num + 1;
                    F_2 = (L_1 * norm(diag(eta_1) * rov.u_i)^2 * E_x_norm^2/4 + norm(diag(eta_1)* diag(k_1) * rov.E_x)^2/4 + norm(diag(eta_1) * rov.E_x)^2) - rho_2 * rov.x_tilde_i' * K_3 * rov.x_tilde_i;
                    F_3 = (L_2 * norm(rov.v_di - rov.w_hat_i - diag(k_3) * rov.beta_sat)^2 * E_x_norm^2 + norm(diag(k_2) * rov.E_x)^2) - rho_3 * rov.delta_xi' * diag(k_2) * rov.delta_xi;
                else
                    trigger_flag(int_num+1) = 0;
                end

                % Update of the dynamic threshold
                rov.beta_est = rov.beta_est + step_size/1000 * (- alpha_2 * rov.beta_est - F_2 + xi_2);
                rov.beta_con = rov.beta_con + step_size/1000 * (- alpha_3 * rov.beta_con - F_3 + xi_3);
                
                % If we want to use time trigger mechanism only
%                 trigger_flag(int_num+1) = 1;
%                 rov.x_i_trigger = rov.x_i;
%                 E_x_norm = 0;
%                 event_num = event_num + 1;

                current_agent_pos_trigger = rov.x_i_trigger;

                % Uncertainty observation
                rov = pc.uncertainty_observer(step_size/1000, rover_R(i), rov);

                % Adaptive observer
                rov = pc.controller(step_size/1000, satu_limit(i), rover_R(i), rov);

                % Communication to Arduino
                r.sendreference(rov.u_i, rov.tcp_port); 
                
            end
            
            % Data recording
            agent_control(int_num+1, (i-1) * dimension + 1 : i * dimension) = rov.u_i';
            beta_sat(int_num+1, (i-1) * dimension + 1 : i * dimension) = rov.beta_sat';
            x_hat(int_num+1, (i-1) * dimension + 1 : i * dimension) = rov.x_hat_i';
            w_hat(int_num+1, (i-1) * dimension + 1 : i * dimension) = rov.w_hat_i';
            u_hat(int_num+1, (i-1) * dimension + 1 : i * dimension) = rov.u_hat_i';
            E_norm(int_num+1) = E_x_norm;
            beta_est(int_num+1) = rov.beta_est;
            beta_con(int_num+1) = rov.beta_con;

            % Record end time
            timer = clock;
            end_time = (timer(4) * 3600 + timer(5) * 60 + timer(6)) * 1000 - ini_time;
            
            agent_sta_time(int_num+1, i) = start_time;
            agent_end_time(int_num+1, i) = end_time;
            
        end
        
        pos_ref(int_num+1, :) = current_pos_ref';
        vel_ref(int_num+1, :) = current_vel_ref';
        agent_pos(int_num+1, :) = current_agent_pos';
        delta_x(int_num+1, :) = current_delta_x';   
        agent_pos_trigger(int_num+1, :) = current_agent_pos_trigger';
        trigger_bound(int_num + 1, :) = rov.trigger_bound';
        
        % Propagation recording
        int_num = int_num + 1;
        
    end
    
    if now_time > stop_time * 1000
        for i = 1 : num_agent
            r.sendreference(zeros(3,1), rov.tcp_port);
        end
        break;
    end
end


%% In case of emergency, run this to stop the system
for i = 1 : num_agent
    r.sendreference(zeros(3,1), rov.tcp_port);
end

%%